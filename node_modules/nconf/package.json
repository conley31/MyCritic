{
  "name": "nconf",
  "description": "Hierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.",
  "version": "0.10.0",
  "author": {
    "name": "Charlie Robbins",
    "email": "charlie.robbins@gmail.com"
  },
  "contributors": [
    {
      "name": "Matt Hamann",
      "email": "matthew.hamann@gmail.com"
    },
    {
      "name": "Maciej MaÅ‚ecki",
      "email": "me@mmalecki.com"
    },
    {
      "name": "Jarrett Cruger",
      "email": "jcrugzz@gmail.com"
    },
    {
      "name": "Adrien Becchis"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/flatiron/nconf.git"
  },
  "keywords": [
    "configuration",
    "key value store",
    "plugabble"
  ],
  "dependencies": {
    "async": "^1.4.0",
    "ini": "^1.3.0",
    "secure-keys": "^1.0.0",
    "yargs": "^3.19.0"
  },
  "devDependencies": {
    "coveralls": "^2.11.4",
    "eslint": "^4.9.0",
    "istanbul": "^0.4.1",
    "nconf-yaml": "^1.0.2",
    "vows": "0.8.x"
  },
  "main": "./lib/nconf",
  "scripts": {
    "test": "vows test/*-test.js test/**/*-test.js --spec",
    "cover": "istanbul cover vows -- test/*-test.js test/**/*-test.js  --spec",
    "coveralls": "cat coverage/lcov.info | coveralls",
    "lint": "eslint ."
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "license": "MIT",
  "readme": "# nconf\n\n[![Version npm](https://img.shields.io/npm/v/nconf.svg?style=flat-square)](https://www.npmjs.com/package/nconf)[![npm Downloads](https://img.shields.io/npm/dm/nconf.svg?style=flat-square)](https://www.npmjs.com/package/nconf)[![Build Status](https://img.shields.io/travis/indexzero/nconf/master.svg?style=flat-square)](https://travis-ci.org/indexzero/nconf)[![Coverage](https://img.shields.io/coveralls/indexzero/nconf.svg?style=flat-square)](https://coveralls.io/github/indexzero/nconf)[![Dependencies](https://img.shields.io/david/indexzero/nconf.svg?style=flat-square)](https://david-dm.org/indexzero/nconf)\n\nHierarchical node.js configuration with files, environment variables, command-line arguments, and atomic object merging.\n\n## Example\nUsing nconf is easy; it is designed to be a simple key-value store with support for both local and remote storage. Keys are namespaced and delimited by `:`. Let's dive right into sample usage:\n\n``` js\n  var fs    = require('fs'),\n      nconf = require('nconf');\n\n  //\n  // Setup nconf to use (in-order):\n  //   1. Command-line arguments\n  //   2. Environment variables\n  //   3. A file located at 'path/to/config.json'\n  //\n  nconf.argv()\n   .env()\n   .file({ file: 'path/to/config.json' });\n\n  //\n  // Set a few variables on `nconf`.\n  //\n  nconf.set('database:host', '127.0.0.1');\n  nconf.set('database:port', 5984);\n\n  //\n  // Get the entire database object from nconf. This will output\n  // { host: '127.0.0.1', port: 5984 }\n  //\n  console.log('foo: ' + nconf.get('foo'));\n  console.log('NODE_ENV: ' + nconf.get('NODE_ENV'));\n  console.log('database: ' + nconf.get('database'));\n\n  //\n  // Save the configuration object to disk\n  //\n  nconf.save(function (err) {\n    fs.readFile('path/to/your/config.json', function (err, data) {\n      console.dir(JSON.parse(data.toString()))\n    });\n  });\n```\n\nIf you run the above script:\n\n``` bash\n  $ NODE_ENV=production sample.js --foo bar\n```\n\nThe output will be:\n\n```\n  foo: bar\n  NODE_ENV: production\n  database: { host: '127.0.0.1', port: 5984 }\n```\n\n## Hierarchical configuration\n\nConfiguration management can get complicated very quickly for even trivial applications running in production. `nconf` addresses this problem by enabling you to setup a hierarchy for different sources of configuration with no defaults. **The order in which you attach these configuration sources determines their priority in the hierarchy.** Let's take a look at the options available to you\n\n  1. **nconf.argv(options)** Loads `process.argv` using yargs. If `options` is supplied it is passed along to yargs.\n  2. **nconf.env(options)** Loads `process.env` into the hierarchy.\n  3. **nconf.file(options)** Loads the configuration data at options.file into the hierarchy.\n  4. **nconf.defaults(options)** Loads the data in options.store into the hierarchy.\n  5. **nconf.overrides(options)** Loads the data in options.store into the hierarchy.\n\nA sane default for this could be:\n\n``` js\n  var nconf = require('nconf');\n\n  //\n  // 1. any overrides\n  //\n  nconf.overrides({\n    'always': 'be this value'\n  });\n\n  //\n  // 2. `process.env`\n  // 3. `process.argv`\n  //\n  nconf.env().argv();\n\n  //\n  // 4. Values in `config.json`\n  //\n  nconf.file('/path/to/config.json');\n\n  //\n  // Or with a custom name\n  // Note: A custom key must be supplied for hierarchy to work if multiple files are used.\n  //\n  nconf.file('custom', '/path/to/config.json');\n\n  //\n  // Or searching from a base directory.\n  // Note: `name` is optional.\n  //\n  nconf.file(name, {\n    file: 'config.json',\n    dir: 'search/from/here',\n    search: true\n  });\n\n  //\n  // 5. Any default values\n  //\n  nconf.defaults({\n    'if nothing else': 'use this value'\n  });\n```\n\n## API Documentation\n\nThe top-level of `nconf` is an instance of the `nconf.Provider` abstracts this all for you into a simple API.\n\n### nconf.add(name, options)\nAdds a new store with the specified `name` and `options`. If `options.type` is not set, then `name` will be used instead:\n\n``` js\n  nconf.add('supplied', { type: 'literal', store: { 'some': 'config' });\n  nconf.add('user', { type: 'file', file: '/path/to/userconf.json' });\n  nconf.add('global', { type: 'file', file: '/path/to/globalconf.json' });\n```\n\n### nconf.any(names, callback)\nGiven a set of key names, gets the value of the first key found to be truthy. The key names can be given as separate arguments \nor as an array. If the last argument is a function, it will be called with the result; otherwise, the value is returned.\n\n``` js\n  //\n  // Get one of 'NODEJS_PORT' and 'PORT' as a return value\n  //\n  var port = nconf.any('NODEJS_PORT', 'PORT');\n\n  //\n  // Get one of 'NODEJS_IP' and 'IPADDRESS' using a callback\n  //\n  nconf.any(['NODEJS_IP', 'IPADDRESS'], function(err, value) {\n    console.log('Connect to IP address ' + value);\n  });\n```\n\n### nconf.use(name, options)\nSimilar to `nconf.add`, except that it can replace an existing store if new options are provided\n\n``` js\n  //\n  // Load a file store onto nconf with the specified settings\n  //\n  nconf.use('file', { file: '/path/to/some/config-file.json' });\n\n  //\n  // Replace the file store with new settings\n  //\n  nconf.use('file', { file: 'path/to/a-new/config-file.json' });\n```\n\n### nconf.remove(name)\nRemoves the store with the specified `name.` The configuration stored at that level will no longer be used for lookup(s).\n\n``` js\n  nconf.remove('file');\n```\n\n### nconf.required(keys)\nDeclares a set of string keys to be mandatory, and throw an error if any are missing.\n\n``` js\n  nconf.defaults({\n    keya: 'a',\n  });\n\n  nconf.required(['keya', 'keyb']);\n  // Error: Missing required keys: keyb\n```\n\n## Storage Engines\n\n### Memory\nA simple in-memory storage engine that stores a nested JSON representation of the configuration. To use this engine, just call `.use()` with the appropriate arguments. All calls to `.get()`, `.set()`, `.clear()`, `.reset()` methods are synchronous since we are only dealing with an in-memory object.\n\n``` js\n  nconf.use('memory');\n```\n\n### Argv\nResponsible for loading the values parsed from `process.argv` by `yargs` into the configuration hierarchy. See the [yargs option docs](https://github.com/bcoe/yargs#optionskey-opt) for more on the option format.\n\n#### Options\n\n##### `parseValues: {true|false}` (default: `false`)\nAttempt to parse well-known values (e.g. 'false', 'true', 'null', 'undefined', '3', '5.1' and JSON values)\ninto their proper types. If a value cannot be parsed, it will remain a string.\n\n##### `transform: function(obj)`\nPass each key/value pair to the specified function for transformation.\n\nThe input `obj` contains two properties passed in the following format:\n```\n{\n  key: '<string>',\n  value: '<string>'\n}\n```\n\nThe transformation function may alter both the key and the value.\n\nThe function may return either an object in the asme format as the input or a value that evaluates to false.\nIf the return value is falsey, the entry will be dropped from the store, otherwise it will replace the original key/value.\n\n*Note: If the return value doesn't adhere to the above rules, an exception will be thrown.*\n\n#### Examples\n\n``` js\n  //\n  // Can optionally also be an object literal to pass to `yargs`.\n  //\n  nconf.argv({\n    \"x\": {\n      alias: 'example',\n      describe: 'Example description for usage generation',\n      demand: true,\n      default: 'some-value',\n      parseValues: true,\n      transform: function(obj) {\n        if (obj.key === 'foo') {\n          obj.value = 'baz';\n        }\n        return obj;\n      }\n    }\n  });\n```\n\nIt's also possible to pass a configured yargs instance\n\n``` js\n  nconf.argv(require('yargs')\n    .version('1.2.3')\n    .usage('My usage definition')\n    .strict()\n    .options({\n      \"x\": {\n        alias: 'example',\n        describe: 'Example description for usage generation',\n        demand: true,\n        default: 'some-value'\n      }\n    }));\n```\n\n### Env\nResponsible for loading the values parsed from `process.env` into the configuration hierarchy.\nBy default, the env variables values are loaded into the configuration as strings.\n\n#### Options\n\n##### `lowerCase: {true|false}` (default: `false`)\nConvert all input keys to lower case. Values are not modified.\n\nIf this option is enabled, all calls to `nconf.get()` must pass in a lowercase string (e.g. `nconf.get('port')`)\n\n##### `parseValues: {true|false}` (default: `false`)\nAttempt to parse well-known values (e.g. 'false', 'true', 'null', 'undefined', '3', '5.1' and JSON values)\ninto their proper types. If a value cannot be parsed, it will remain a string.\n\n##### `transform: function(obj)`\nPass each key/value pair to the specified function for transformation.\n\nThe input `obj` contains two properties passed in the following format:\n```\n{\n  key: '<string>',\n  value: '<string>'\n}\n```\n\nThe transformation function may alter both the key and the value.\n\nThe function may return either an object in the asme format as the input or a value that evaluates to false.\nIf the return value is falsey, the entry will be dropped from the store, otherwise it will replace the original key/value.\n\n*Note: If the return value doesn't adhere to the above rules, an exception will be thrown.*\n\n#### Examples\n\n``` js\n  //\n  // Can optionally also be an Array of values to limit process.env to.\n  //\n  nconf.env(['only', 'load', 'these', 'values', 'from', 'process.env']);\n\n  //\n  // Can also specify a separator for nested keys (instead of the default ':')\n  //\n  nconf.env('__');\n  // Get the value of the env variable 'database__host'\n  var dbHost = nconf.get('database:host');\n\n  //\n  // Can also lowerCase keys. \n  // Especially handy when dealing with environment variables which are usually \n  // uppercased while argv are lowercased.\n  //\n\n  // Given an environment variable PORT=3001\n  nconf.env();\n  var port = nconf.get('port') // undefined\n\n  nconf.env({ lowerCase: true });\n  var port = nconf.get('port') // 3001\n\n  //\n  // Or use all options\n  //\n  nconf.env({\n    separator: '__',\n    match: /^whatever_matches_this_will_be_whitelisted/\n    whitelist: ['database__host', 'only', 'load', 'these', 'values', 'if', 'whatever_doesnt_match_but_is_whitelisted_gets_loaded_too'],\n    lowerCase: true,\n    parseValues: true,\n    transform: function(obj) {\n      if (obj.key === 'foo') {\n        obj.value = 'baz';\n      }\n      return obj;\n    }\n  });\n  var dbHost = nconf.get('database:host');\n```\n\n### Literal\nLoads a given object literal into the configuration hierarchy. Both `nconf.defaults()` and `nconf.overrides()` use the Literal store.\n\n``` js\n  nconf.defaults({\n    'some': 'default value'\n  });\n```\n\n### File\nBased on the Memory store, but provides additional methods `.save()` and `.load()` which allow you to read your configuration to and from file. As with the Memory store, all method calls are synchronous with the exception of `.save()` and `.load()` which take callback functions.\n\nIt is important to note that setting keys in the File engine will not be persisted to disk until a call to `.save()` is made. Note a custom key must be supplied as the first parameter for hierarchy to work if multiple files are used.\n\n``` js\n  nconf.file('path/to/your/config.json');\n  // add multiple files, hierarchically. notice the unique key for each file\n  nconf.file('user', 'path/to/your/user.json');\n  nconf.file('global', 'path/to/your/global.json');\n```\n\nThe file store is also extensible for multiple file formats, defaulting to `JSON`. To use a custom format, simply pass a format object to the `.use()` method. This object must have `.parse()` and `.stringify()` methods just like the native `JSON` object.\n\nIf the file does not exist at the provided path, the store will simply be empty.\n\n#### Encrypting file contents\n\nAs of `nconf@0.8.0` it is now possible to encrypt and decrypt file contents using the `secure` option:\n\n``` js\nnconf.file('secure-file', {\n  file: 'path/to/secure-file.json',\n  secure: {\n    secret: 'super-secretzzz-keyzz',\n    alg: 'aes-256-ctr'\n  }\n})\n```\n\nThis will encrypt each key using [`crypto.createCipher`](https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password), defaulting to `aes-256-ctr`. The encrypted file contents will look like this:\n\n```\n{\n  \"config-key-name\": {\n    \"alg\": \"aes-256-ctr\", // cipher used\n    \"value\": \"af07fbcf\"   // encrypted contents\n  },\n  \"another-config-key\": {\n    \"alg\": \"aes-256-ctr\",   // cipher used\n    \"value\": \"e310f6d94f13\" // encrypted contents\n  },\n}\n```\n\n### Redis\nThere is a separate Redis-based store available through [nconf-redis][0]. To install and use this store simply:\n\n``` bash\n  $ npm install nconf\n  $ npm install nconf-redis\n```\n\nOnce installing both `nconf` and `nconf-redis`, you must require both modules to use the Redis store:\n\n``` js\n  var nconf = require('nconf');\n\n  //\n  // Requiring `nconf-redis` will extend the `nconf`\n  // module.\n  //\n  require('nconf-redis');\n\n  nconf.use('redis', { host: 'localhost', port: 6379, ttl: 60 * 60 * 1000 });\n```\n\n## Installation\n``` bash\n  npm install nconf --save\n```\n\n## Run Tests\nTests are written in vows and give complete coverage of all APIs and storage engines.\n\n``` bash\n  $ npm test\n```\n\n#### Author: [Charlie Robbins](http://nodejitsu.com)\n#### License: MIT\n\n[0]: http://github.com/indexzero/nconf-redis\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/flatiron/nconf/issues"
  },
  "_id": "nconf@0.10.0",
  "dist": {
    "shasum": "23e8890b374465ce5f78a0e7e8863c6df1a7bb9b"
  },
  "_from": "nconf@",
  "_resolved": "https://registry.npmjs.org/nconf/-/nconf-0.10.0.tgz"
}
